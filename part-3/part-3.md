# The most common RxJS operators

Contributors:

- Andrew Grekov

#

# **RxJS операторы, которые вы используете каждый день**

# Comment

Когда вы только начинаете работать с **RxJS** , то вам необходимо узнать о нескольких важных операторов, которые вы будете использовать повсеместно. В этой части курса мы рассмотрим часто встречающиеся операторы и попутно вместе с вами применим их на практике.

#

# **Изменяем значения в потоке**

## **from()**

Чтобы нам начать работать с потоками **RxJS** , мы воспользуемся оператором **from()**.

**from()** создает потом из переданного значения. Например, если передать список, то создастся поток со значениями этого списка.

```ts
import { from } from "rxjs";

const source = from([1, 2, 3]);

// Выведет в консоль:

//. 1

//. 2

//. 3

source.subscribe((value) => console.log(value));
```

Как видно из примера, **from()** создает поток с переданными значения списка.

## **map()**

Создавать потоки здорово и интересно, но еще более потрясающе будет изменять значения потоков. Например, давайте умножим каждое значение потока на 2. Для этого мы можем применить оператор **map()**.

**map()** обрабатывает каждое значения потока отдельно. Это полный аналог **Array.prototype.map** , только для потоков.

```ts
import{from}from'rxjs';

import{ map }from'rxjs/operators';

const source =from([1,2,3]).pipe(

// Умножаем каждое значение на 2

map((value)=> value \*2)

);

// Выведет в консоль:

//. 2

//. 4

//. 6

source.subscribe((value)=>console.log(value));
```

Как видно из примера, **map()** позволяет нам обрабатывать каждое значение, изменять его и возвращать обратно в поток.

#

# **Фильтруем значения в потоке**

## **filter()**

Иногда, мы сталкиваемся с задачей, когда мы не хотим, чтобы значение проходило дальше. Например, мы хотим, чтобы четные числа проходили по потоку дальше. Для этого используется оператор **filter()**.

**filter()** оператор фильтрует каждое значение потока. Это полный аналог **Array.prototype.filter** , только для потоков.

```ts
import { from } from "rxjs";

import { filter } from "rxjs/operators";

const source = from([1, 2, 3, 4]).pipe(
  // Проверяем, является ли значение четным

  filter((value) => isEven(value))
);

// Выведет в консоль:

//. 2

//. 4

source.subscribe((value) => console.log(value));
```

Как видно из примера, \*\*filter() позволяет нам фильтровать каждое значение, и решать пропускать его дальше в поток или нет.

## **skip(), first(), take()**

Иногда нам необходимо пропустить несколько значений, или взять только одно или несколько первых. Давайте посмотрим, как это может выглядеть с использованием оператора **filter()**.

```ts
import { from } from "rxjs";

import { filter } from "rxjs/operators";

const source = from([1, 2, 3]).pipe(
  // Пропустит первое значение и будет возвращать все остальные

  filter((value, index) => index > 0)
);

// Выведет в консоль:

//. 2

//. 3

source.subscribe((value) => console.log(value));
```

**RxJS** предоставляет нам готовые операторы для этих целей. Давайте применим оператор **skip()** и перепишем код выше.

**skip()** оператор позволяет указывать сколько элементов потока необходимо пропустить.

```ts
import { from } from "rxjs";

import { skip } from "rxjs/operators";

const source = from([1, 2, 3]).pipe(
  // Пропустит первое значение и будет возвращать все остальные

  skip(1)
);

// Выведет в консоль:

//. 2

//. 3

source.subscribe((value) => console.log(value));
```

Как видно из примера, мы заменили **filter()** на оператор **skip()**, что сделало наш код компактнее и понятнее. Теперь наш код смотрится более декларативно.

Давайте теперь возьмем только первые несколько значений из потока. Для этого нам понадобятся операторы **take()** и **first()**.

**take()** берет указанное количество значений из потока, и завершает поток.

**first()** берет только первое значение из потока, и завершает поток. Обратите внимание, что если поток не вернет значение, то будет выброшено исключение **EmptyError**.

```ts
import { from } from "rxjs";

import { take, first } from "rxjs/operators";

const source = from([1, 2, 3]);

const sourceTakeTwo = source.pipe(
  // Возьмет первые два значения и завершит поток

  take(2)
);

// Выведет в консоль:

//. 1

//. 2

sourceTakeTwo.subscribe((value) => console.log(value));

const sourceTakeFirst = source.pipe(
  // Возьмет первое значение и завершит поток

  first()
);

// Выведет в консоль:

//. 1

sourceTakeFirst.subscribe((value) => console.log(value));
```

Отлично! Теперь мы умеем брать несколько первых или несколько последних значений из потока. Давайте посмотрим, как еще можно фильтровать значения с помощью операторов **RxJS**.

## **distinctUntilChanged()**

Иногда, нам может потребоваться фильтровать значения из потока, которые повторяются друг за другом. Для этого можно использовать оператор **distinctUntilChanged()**.

**distinctUntilChanged()** убирает повторяющиеся друг за другом значения в потоке.

```ts
import { from } from "rxjs";

import { distinctUntilChanged } from "rxjs/operators";

const source = from([1, 1, 2, 2, 2, 3, 3, 1, 1]).pipe(
  // Не пропустит значение, если оно было предыдущим

  distinctUntilChanged()
);

// Выведет в консоль:

//. 1

//. 2

// 3

//. 1

source.subscribe((value) => console.log(value));
```

Как видно из примера, **distinctUntilChanged()** пропустил только первые из повторяющихся значений.

#

# **Объединение потоков**

Иногда бывает так, что нам необходимо правильно обработать значения сразу с нескольких потоков. Для начала давайте просто их создадим, как это делали раньше. Для этого воспользуемся оператором **timer()**.

## **timer()**

**timer()** создает поток, который будет возвращать новые значения с таймаутом.

```ts
import { timer } from "rxjs";

// Первое значение вернет сразу, а остальные каждую секунду

const sourceFirst = timer(0, 1000);

// Выведет в консоль:

//. 0 сразу

//. 1 через 1.0 sec

// 2 через 2.0 sec

sourceFirst.subscribe((value) => console.log(value));

// Первое значение через 0.5 секунды, а остальные каждую секунду

const sourceSecond = timer(500, 1000);

// Выведет в консоль:

//. 0 через 0.5 sec

//. 1 через 1.5 sec

// 2 через 2.5 sec

sourceSecond.subscribe((value) => console.log(value));
```

## **combineLatest()**

Теперь давайте объединим значения этих потоков! Для этого воспользуемся оператором **combineLatest()**.

**combineLatest()** объединяет переданные потоки и возвращает значение из всех последних значений потоков.

```ts
import { timer, combineLatest } from "rxjs";

// Первое значение вернет сразу, а остальные каждую секунду

const sourceFirst = timer(0, 1000);

// Первое значение через 0.5 секунды, а остальные каждую секунду

const sourceSecond = timer(500, 1000);

const source = combineLatest([sourceFirst, sourceSecond]);

// Выведет в консоль:

//. [0, 0] через 0.5 sec

//. [1, 0] через 1.0 sec

// [1, 1] через 1.5 sec

// [2, 1] через 2.0 sec

source.subscribe((value) => console.log(value));
```

Смотрите! Не смотря на то, что значения в потоках генерируются в разное время, нам удалось их свести к одному значению, что позволяет нам одновременно обрабатывать сразу два значения из потока.

## **withLastestFrom()**

Как вы могли заметить, мы получали новое значение каждый раз, когда значение в одном из потоков менялось. А что если, нам надо получать новое значение только тогда, когда поменялся основной поток? Давайте это сделаем с помощью оператора **withLatestFrom()**.

**withLatestFrom()** комбинирует текущий поток с переданным потоком, и создает новое значение только тогда, когда оно добавилось в основном потоке.

```ts
import { timer } from "rxjs";

import { withLatestFrom } from "rxjs/operators";

// Первое значение вернет сразу, а остальные каждую секунду

const sourceFirst = timer(0, 1000);

// Первое значение через 0.5 секунды, а остальные каждую секунду

const sourceSecond = timer(500, 1000);

const source = sourceFirst.pipe(withLatestFrom(sourceSecond));

// Выведет в консоль:

//. [1, 0] через 1.0 sec

// [2, 1] через 2.0 sec

// [3, 2] через 3.0 sec

source.subscribe((value) => console.log(value));
```

Разница с предыдущим примером в том, что теперь новое значение создается только тогда, когда изменяется основной поток.

#

# **Обработка ошибок в потоках**

В реальных приложениях могут происходить исключительные ситуации, и нам необходимо их правильно обработать. Давайте создадим исключение в потоке, чтобы посмотреть что произойдет.

```ts
import { from } from "rxjs";

import { map } from "rxjs/operators";

const source = from([1, 2, 3]).pipe(
  // Что-то пошло не так

  map(() => {
    thrownewError("Unexpected 🙀!");
  })
);

// Выбросится исключение:

//. Error: Unexpected 🙀!

source.subscribe((value) => console.log(value));
```

И в данном случае это исключение никак не обрабатывается. Чтобы его обработать, необходимо воспользоваться оператором **catchError()**.

**catchError()** обрабатывает все исключения, которые происходят в потоке. Обратите внимание, что старый поток завершается, поэтому оператор возвращает новый поток.

```ts
import { from, of } from "rxjs";

import { map, catchError } from "rxjs/operators";

const source = from([1, 2, 3]).pipe(
  // Что-то пошло не так

  map(() => {
    thrownewError("Unexpected 🙀!");
  }),

  // Обработаем это!

  catchError(() => of("Expected 😻!"))
);

// Выведется в консоль:

//. Expected 😻!

source.subscribe((value) => console.log(value));
```

Теперь мы можем быть уверены в том, что код отработает правильно, а исключения будут обработаны.

#

# **В заключении**

Мы разобрали самые популярные операторы **RxJS** и научились: изменять данные в потоке, фильтровать данные в потоке, объединять данные потоков и обрабатывать ошибки в потоке.

Мы молодцы! 👏
